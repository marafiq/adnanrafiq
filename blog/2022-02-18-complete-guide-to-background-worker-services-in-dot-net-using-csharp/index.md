---
title: A Complete Guide to Background Worker Service(s) in .NET 6 using C# 10 
description: A Complete Guide to Background Worker Service(s) in .NET 6 using C# 10 
slug: complete-guide-to-background-worker-services-in-dot-net-using-csharp 
authors: adnan 
tags: [C#, .NET6, BackgroundWorkerService]
image : ./heroImage.jpg
keywords: [Background,Worker,Service,.NET6,LongRunningTasks]
draft: true
---

## What is Background Service?
A service that performs the work in the background mostly does not offer an interface to interact.
.NET 6 (Starting from .NET Core 2.0) provides two flavors of background services but both implements `IHostedService`:
- An independent deployable process which is hosting one or many services. It is also known as Worker Process.
- ASP.NET Hosted Service(s) runs inside the same process of ASP.NET Web Server.
<!--truncate-->

## What is Host?
The Host is a container which offers rich built-in services such as Dependency Injection, Configuration, Logging, Host Services and others. The NET 6 offers Generic DefaultHost which can be configured to handle the activities as per your use case. Two major variations of the Host are:
- Console Host - CLI based applications.
- Web Host - Web API & Applications.

Think of it as Airbnb Host who keeps the property ready to serve when the guests arrive. The property offers a different set of services. The lifetime of such services depends upon the contract, which the Host controls.

~~~csharp title="Create, configure, build, and run the Host"
var host = Host.CreateDefaultBuilder(args) //WebHost.CreateDefaultBuilder(args)  
    .ConfigureLogging( (context, builder) => builder.AddConsole())
    .Build(); // Build the host, as per configurations.

await host.RunAsync();
~~~

## What is Hosted Service?
A service that implements the `IHostedService` interface is a Hosted Service. The interface has `StartAsync` and `StopAsync,` which the Host triggers.
- `StartAsync` method when the Host is ready to start the hosted service.
- `StopAsync` method when the Host is gracefully shutting down the hosted service.

```csharp title="Basic IHostedService Example"
public class LongRunningTaskService : IHostedService
{
    public Task StartAsync(CancellationToken cancellationToken)
    {
        // Start the work
        throw new NotImplementedException();
    }

    public Task StopAsync(CancellationToken cancellationToken)
    {
        //Graceful shutdown from the Host
        throw new NotImplementedException();
    }
}
```
:::note
The `StartAsync` method should not block the execution because if multiple hosted services exist in the Host, the following services will not start until the first service finish the start. We will see a demo of such behavior later in the post.
:::
### Worker Process
You can create worker process using .NET CLI command `dotnet new worker` with default template.
You will find the following code in `Program.cs`.
~~~csharp title="Notice the highlighted line"
var host = Host.CreateDefaultBuilder(args)   
    .ConfigureLogging( (context, builder) => builder.AddConsole())
    // highlight-next-line
    .ConfigureServices(services => { services.AddHostedService<Worker>(); })
    .Build(); // Build the host, as per configurations.

await host.RunAsync();
~~~

`services.AddHostedService<Worker>()` adds the Hosted Service to the collection of the Host Services. Since it implements IHostedService interface, the Host knows how to start it and gracefully shutdown if required.

You will find the following code in `Worker.cs`.
```csharp title="Code generated by default template"
// highlight-next-line
public class Worker : BackgroundService
{
    private readonly ILogger<Worker> _logger;

    public Worker(ILogger<Worker> logger)
    {
        _logger = logger;
    }
    // highlight-next-line
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        // highlight-next-line
        while (!stoppingToken.IsCancellationRequested)
        {
            _logger.LogInformation("Worker running at: {time}", DateTimeOffset.Now);
            await Task.Delay(1000, stoppingToken);
        }
        //Once execution leaves this method, it will not be called again.
    }
}
```
The `Worker` inherits from [`BackgroundService`](https://gist.github.com/marafiq/c3e08c1892600cda1a0af8df00358a2e) which is abstract class, and implements `IHostedService`.
The `BackgroundService` encapsulates the implementation of `StartAsync`, `StopAsync`, creation of `CancellationTokenSource` and disposal of resources.

The ExecuteAsync is inherited & triggered from the BackgroundService with the CancellationToken, which offers us to complete our work when Token cancellation is not requested. The cancellation can happen if you press ctrl + c or if the Host decides to stop the Hosted Services gracefully. The completion of `ExecuteAsync` means that the service has finished its work. So if the requirement is to poll continuously, then use the infinite while loop, for example, processing the messages from the queue as they arrive.

### ASP.NET Hosted Service
ASP.NET hosted service implements the `IHostedSerivce` interface. It is different from the worker process only where it resides in memory, and it's part of the ASP.NET webserver process, which means it can access the memory of the process. Sharing the same process memory makes it very powerful because it can manipulate objects in the memory space. It is handy for maintaining consistent cache, fire & forget type operations. 

### Listen to HostService Lifetime events and stop programmatically
The Host provides `IHostApplicationLifetime` service which allows consumers to listen to changes in lifetime of the Hosted Services and stop the hosted service programmatically.

<details>

<summary>IHostApplicationLifetime interface contract with detail comments.</summary>

```csharp
/// <summary>
/// Allows consumers to be notified of application lifetime events. This interface is not intended to be user-replaceable.
/// </summary>
public interface IHostApplicationLifetime
{
    /// <summary>
    /// Triggered when the application host has fully started.
    /// </summary>
    CancellationToken ApplicationStarted { get; }

    /// <summary>
    /// Triggered when the application host is starting a graceful shutdown.
    /// Shutdown will block until all callbacks registered on this token have completed.
    /// </summary>
    CancellationToken ApplicationStopping { get; }

    /// <summary>
    /// Triggered when the application host has completed a graceful shutdown.
    /// The application will not exit until all callbacks registered on this token have completed.
    /// </summary>
    CancellationToken ApplicationStopped { get; }

    /// <summary>
    /// Requests termination of the current application.
    /// </summary>
    void StopApplication();
}
```

</details>

<details>

<summary>How to log IHostApplicationLifetime events and stop the hosted service programmatically.</summary>

```csharp title="Highlghted lines show the usage of IHostApplicationLifetime."
public class Worker : BackgroundService
{
    private readonly ILogger<Worker> _logger;
    private readonly IHostApplicationLifetime _hostApplicationLifetime;

    public Worker(ILogger<Worker> logger, IHostApplicationLifetime hostApplicationLifetime)
    {
        _logger = logger;
        _hostApplicationLifetime = hostApplicationLifetime;
    }

    public override Task StartAsync(CancellationToken cancellationToken)
    {
        try
        {
            //highlight-start
            // callback methods when host is gracefully shutting down the service
            _hostApplicationLifetime.ApplicationStarted.Register(() => _logger.LogInformation("started"));
            _hostApplicationLifetime.ApplicationStopping.Register(() => _logger.LogInformation("stopping"));
            _hostApplicationLifetime.ApplicationStopped.Register(() => _logger.LogInformation("stopped"));
            //highlight-end
            return base.StartAsync(cancellationToken);
        }
        catch (Exception e)
        {
            _logger.LogError(e.Message);
            return Task.CompletedTask;
        }
    }

    public override async Task StopAsync(CancellationToken cancellationToken)
    {
        var stopWatch = Stopwatch.StartNew();
        await base.StopAsync(cancellationToken);
        // it will print 30 seconds if stopped with ctrl + c
        _logger.LogInformation($"Worker Service Stopped in : {stopWatch.ElapsedMilliseconds}");
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        stoppingToken.Register(() => _logger.LogInformation($"Worker service token is canceled"));

        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                await DoWork();
            }
            catch (Exception e)
            {
                _logger.LogCritical(e, "I can not work anymore!");
            }
            finally
            {
                //highlight-start
                // if you can not recover, stop it.
                // All hosted services in host will be stopped in reverse order of registration
                _hostApplicationLifetime.StopApplication();
                //highlight-end
            }
        }
    }

    private async Task<bool> DoWork()
    {
        _logger.LogInformation("I started doing work!");
        // press ctrl + c - after above message - ctrl + c is equal to StopService from Windows Host
        // defualt graceful shutdown is 6 seconds
        // work will never complete
        await Task.Delay(50000);
        _logger.LogInformation("I am done with work.");
        return true;
    }
}
```
</details>


### Control Graceful Shutdown time
Default graceful stop time is 5 seconds. If the Hosted Service requires more than 5 seconds to complete the in-progress work, then you can extend it by configuring the Host.
```csharp title="How to extend the graceful shtudown time. Notice the highlighted line below."
IHost host = Host.CreateDefaultBuilder(args)
    .ConfigureLogging( (context, builder) => builder.AddConsole())
    .ConfigureServices(services =>
    {
        services.Configure<HostOptions>(options =>
        {
          	// highlight-next-line
            options.ShutdownTimeout = TimeSpan.FromSeconds(30);
        });
        services.AddHostedService<Worker>();
    })
    .Build();
```
`AddHostedService<Worker>()` adds a Singleton Instance of Worker to the default .NET DI Container.


If your use case involves using a scoped type instance of any object, you will have to access the instance using IServiceProvider.

```csharp title="How to utilize scoped services inside the Hosted Service."

IHost host = Host.CreateDefaultBuilder(args)
    .ConfigureLogging( (context, builder) => builder.AddConsole())
    .ConfigureServices(services =>
    {
        // highlight-next-line
        services.AddScoped<IAnyScopeService>();
        services.AddHostedService<Worker>();
    })
    .Build();

await host.RunAsync();

public interface IAnyScopeService
{
    Task<bool> DoWork();
}

public class AnyScopeService : IAnyScopeService
{
    public Task<bool> DoWork() => Task.FromResult(true);
}

public class Worker : BackgroundService
{
    private readonly IServiceScopeFactory _serviceScopeFactory;
    /* Do not do this. IAnyScopeService will be singleton instance.
    private readonly IAnyScopeService _anyScopeService;
    public Worker(IAnyScopeService anyScopeService)
    {
        _anyScopeService = anyScopeService;
    }
    */
    public Worker(IServiceScopeFactory serviceScopeFactory)
    {
        _serviceScopeFactory = serviceScopeFactory;
    }
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (stoppingToken.IsCancellationRequested == false)
        {
            using var scope = _serviceScopeFactory.CreateScope();
            var anyScopeService = scope.ServiceProvider.GetService<IAnyScopeService>();
            await anyScopeService!.DoWork();
        }
    }
}

```

:::caution
Do not inject EF Context Instance into the constructor of the Hosted Service unless it is intentional.
If you are querying many records using the EF Context, it will cause memory saturation and an eventual crash.
:::

## Multiple Host Services, and their Start & Stop
If the Host contains multiple hosted services, it will start those services serially in order they are registered, but stops will happen in reverse order serially.
It can be essential to control the gracefully shut time behavior & how these services will stop so that business operation does not end up inconsistent. 

Consider, a hosted service is writing to a channel, and another hosted service is reading from that channel. If writer service is registered first, then it will stop last. It means the writer service may have written some data to channel, while there is no reader to read it.   
